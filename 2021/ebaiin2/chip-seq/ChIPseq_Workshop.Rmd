---
title: "EBAIIn2 - ChIP-seq Workshop"
author: "Elodie Darbo$^{1}$ - elodie.darbo@u-bordeaux.fr; Stephanie Le Gras$^{2}$ - slegras@igbmc.fr"
date: "2021 May"
output:
  html_document:
    fig_caption: yes
    toc: true
    toc_depth: 5
    toc_float: true
    number_sections: true
  pdf_document:
    fig_caption: yes
    keep_tex: yes
    toc: true
    toc_depth: 3
params:
  ensembl: 103
  assembly: hg38
  organism: Homo sapiens
  #<!-- path.peaks: /Volumes/ngs/illumina/slegras/B21000_EBAIIv2/2021-05-07_PeakCalling/ -->
  #path.peaks: /Users/slegras/Documents/Formations/EBAII/2021/ebaiin2/chip-seq/data/
  mapping.chipseq: data/stats_mappingChIPseq.tsv
  peakcalling.chipseq: data/stats_peakCalling.tsv
  path.peaks: /Users/slegras/Documents/Formations/EBAII/2021/ebaiin2/chip-seq/data/
  brg1: BRG1siCTRL_CHIP-seq_peaks.narrowPeak
  mitf: MITF_CHIP-seq_peaks.narrowPeak
  sox10: SOX10_CHIP-seq_peaks.narrowPeak
  #<!-- path.bw: /Volumes/ngs/illumina/slegras/B21000_EBAIIv2/2021-05-10_bigWigs/ -->
  #path.bw: /Users/slegras/Documents/Formations/EBAII/2021/ebaiin2/chip-seq/data/
  path.bw: /Users/slegras/Documents/Formations/EBAII/2021/ebaiin2/chip-seq/data/
  brg1.bw: BRG1siCTRL_CHIP-seq.bw
  mitf.bw: MITF_CHIP-seq.bw
  sox10.bw: SOX10_CHIP-seq.bw
  rnaseq: /Users/slegras/Documents/Formations/EBAII/2021/ebaiin2/chip-seq/RNAseq_diff_norm.RData
bibliography: references.bib
---

```{r setup, include=FALSE}
#knitr::opts_knit$set(echo = TRUE,  root.dir="/Users/slegras/Documents/Formations/EBAII/2021/ebaiin2/chip-seq/", fig.path = "images/")
knitr::opts_knit$set(echo = TRUE,  root.dir="/Users/slegras/Documents/Formations/EBAII/2021/ebaiin2/chip-seq/", fig.path = "images/")
```

$^1$

$^2$ GenomEast platform, IGBMC

```{r, eval=F,echo=F}
params <- list(path.bw= "/Users/slegras/Documents/Formations/EBAII/2021/ebaiin2/chip-seq/",
              path.peaks= "/Users/slegras/Documents/Formations/EBAII/2021/ebaiin2/chip-seq/",
              brg1= "BRG1siCTRL_CHIP-seq_peaks.narrowPeak",
              mitf= "MITF_CHIP-seq_peaks.narrowPeak",
              sox10= "SOX10_CHIP-seq_peaks.narrowPeak",
              brg1.bw= "BRG1siCTRL_CHIP-seq.bw",
              mitf.bw= "MITF_CHIP-seq.bw",
              sox10.bw= "SOX10_CHIP-seq.bw",
              rnaseq= "/Users/slegras/Documents/Formations/EBAII/2021/ebaiin2/chip-seq/RNAseq_diff_norm.RData"
)
```

# Introduction
During this training session, we are going to analyze data from Laurette et al. [@laurette_transcription_2015] which data are deposited in GEO as [GSE61967](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE61967). There are ChIP-seq and RNA-seq data. Data were downloaded from GEO and processed.

## Processing of RNA-seq data
### Preprocessing
Reads were preprocessed in order to remove adapter, polyA and low-quality sequences (Phred quality score below 20). After this preprocessing, reads shorter than 40 bases were discarded for further analysis. These preprocessing steps were performed using cutadapt [@martin_cutadapt_2011] version 1.10.

### Mapping
Reads were mapped onto the hg38 assembly of Homo sapiens genome using STAR [@dobin_star:_2013] version 2.5.3a.

### Quantification
Gene expression quantification was performed from uniquely aligned reads using htseq-count verson 0.6.1.p1 [@anders_htseqpython_2015], with annotations from Ensembl version 103 and “union” mode. Only non-ambiguously assigned reads have been retained for further analyses.

### Normalization
Read counts have been normalized across samples with the median-of-ratios method proposed by Anders and Huber [@AND2010], to make these counts comparable between samples.

## Processing of ChIP-seq data
### Mapping
Reads were mapped to ``r params$organism`` genome (assembly ``r params$assembly``) using Bowtie [@langmead_ultrafast_2009] v1.0.0 with default parameters except for "-p 3 -m 1 --strata --best --chunkmbs 128". The following table shows the number of reads aligned to the ``r params$organism`` genome.

```{r stats.chipseq, echo=FALSE}
align.stat <- read.table(params$mapping.chipseq, sep="\t", quote="", header=T, check.names = F)

library(knitr)

align.stat = align.stat[order(align.stat$"Sample ID"),]

kable(align.stat, caption = "Mapping statistics of ChIP-seq data analyzed during this training session. Raw corresponds to the number of sequenced reads. Aligned corresponds to the number of reads aligned exactly 1 time. Multimapped corresponds to the number of reads aligned > 1 times. Unmapped corresponds to the number of reads aligned 0 time.", row.names = FALSE)

```

### Peak Calling
Prior to peak calling, reads falling into Encode blacklisted regions [@anshulkundaje_2014] were removed using bedtools intersect v2.26.0 [@quinlan_bedtools:_2010]. Then peak calling was done with Macs2 v2.1.1 with default parameters.

```{r peakcalling, echo=FALSE}

peak.stat <- read.table(params$peakcalling.chipseq, sep="\t", quote="", header=T, check.names = F)

peak.stat = peak.stat[order(peak.stat$"IP sample"),]

kable(peak.stat, caption = "Number of peaks detected", row.names = FALSE)
```

### Generation of BigWig files
Normalized BigWig files were generated using Homer [@heinz_simple_2010] makeUCSCfile v4.11.0 with the following parameter ’-norm 1e7’ meaning that data were normalized to 10M reads.

# Description and statistics of BRG1 dataset
## Load data
Peak files are in narrowPeak format which is of the form ([source](https://genome.ucsc.edu/FAQ/FAQformat.html#format12)):

1. chrom - Name of the chromosome (or contig, scaffold, etc.).
2. chromStart - The starting position of the feature in the chromosome or scaffold. The first base in a chromosome is numbered 0.
3. chromEnd - The ending position of the feature in the chromosome or scaffold. The chromEnd base is not included in the display of the feature. For example, the first 100 bases of a chromosome are defined as chromStart=0, chromEnd=100, and span the bases numbered 0-99.
4. name - Name given to a region (preferably unique). Use "." if no name is assigned.
5. score - Indicates how dark the peak will be displayed in the browser (0-1000). If all scores were "'0"' when the data were submitted to the DCC, the DCC assigned scores 1-1000 based on signal value. Ideally the average signalValue per base spread is between 100-1000.
6. strand - +/- to denote strand or orientation (whenever applicable). Use "." if no orientation is assigned.
7. signalValue - Measurement of overall (usually, average) enrichment for the region.
8. pValue - Measurement of statistical significance (-log10). Use -1 if no pValue is assigned.
9. qValue - Measurement of statistical significance using false discovery rate (-log10). Use -1 if no qValue is assigned.
10. peak - Point-source called for this peak; 0-based offset from chromStart. Use -1 if no point-source called.

```{r loadData, include=TRUE}
## The package ChIPseeker provides a function to load peak files such as narrowPeaks as GRanges objects
## Here BRG1 peak set is loaded into a list of peaks
## this list can be extended if there are more datasets
library(ChIPseeker)

peaks <- list()
peaks[["BRG1"]] <- readPeakFile(paste0(params$path.peaks, params$brg1), as="GRanges")

peaks
```

Peaks are stored as **GenomicRanges** objects; this is an R format which look like the bed format, but is optimized in terms of memory requirements and speed of execution.

We can start by computing some basic statistics on the peak sets.

## How many peaks were called?
Compute the number of peaks per dataset.
```{r peaksStats2, include=TRUE}
# sapply() function takes list, vector or data frame as input and gives output in vector or matrix
# sapply apply the same function (here length) to all elements
# of the list "peaks"
sapply(peaks,length)
```

Make a simple barplot showing the number of peaks per chipped protein.
```{r simplebarplot, include=TRUE}
barplot(sapply(peaks,length))
```

Let's create a barplot with ggplot2 out of this data.
```{r enhancedbarplot, include=TRUE}
# Load ggplot2 library
library(ggplot2)

# create a table with the data to display
peak.lengths <- data.frame(IP=names(peaks),
                           NbPeaks=sapply(peaks,length))

# make the barplot
ggplot(peak.lengths, aes(x=IP, y=NbPeaks)) +
         geom_bar(stat="identity")

# Let's add colors to the barplot
# In R it exists some already defined colors palettes
# the most widely used palette is RColorBrewer.
# This R library offers several color palettes
# See:
library(RColorBrewer)
par(mar=c(3,4,2,2))
display.brewer.all()

# now lets add colors to the barplot
# first ass the new information, fill=IP to let ggplot know
# that colors change based on chipped protein
ggplot(peak.lengths, aes(x=IP, y=NbPeaks, fill=IP)) +
         geom_bar(stat="identity")

# if we want to use colors from RColorBrewer library
# with the "Set1" color palette
ggplot(peak.lengths, aes(x=IP, y=NbPeaks, fill=IP)) +
         geom_bar(stat="identity")+
         scale_fill_brewer(palette="Set1")
```

## How large are these peaks?
Compute statistics on BRG1 peak sizes
```{r peakWidth, message=FALSE, include=TRUE}
## we use the function width() from GenomicRanges
library(GenomicRanges)
summary(width(peaks$BRG1))
```

Create a simple boxplot of the peak sizes.
```{r simpleboxplot, message=FALSE, include=TRUE}
peak.width <- lapply(peaks,width)
boxplot(peak.width)
```

Now, create a nice looking boxplot with ggplot2. ggplot takes a data frame as input. We can either create a date frame, this is what we have done when we created the barplot. Here, we are going to use a package that creates a data frame from other types of data: reshape2.
```{r reshape, message=FALSE, include=TRUE}
# Load the package
library(reshape2)
peak.width.table <- melt(peak.width)
head(peak.width.table)

## create boxplot
ggplot(peak.width.table, aes(x=L1, y=value)) +
         geom_boxplot()
```

Enhance it.
```{r enhancedboxplot2, message=FALSE, include=TRUE}
# - theme_classic() change grey background to white background
# - fill=L1 and scale_fill_brewer(palette="Set1") colors boxplots
# based on chipped protein and with colors from RColorBrewer Set1 palette
# - labs changes x and y axis labels and legend title
# - scale_y_log10() set y axis to a log scale so that we can have a nice
# view of the data in small values
ggplot(peak.width.table, aes(x=L1, y=value, fill=L1)) +
         geom_boxplot()+
         theme_classic()+
         scale_fill_brewer(palette="Set1")+
         labs(x = "", y = "Peak sizes", fill = "")+
         scale_y_log10()

```

## Peak filtering
To make sure we keep only high quality data. We are going to select one those peaks having a qValue >= 8. The qValue corresponds to the 9th column of narrowPeak files. So, we are going to set a threshold on this.

```{r peakFilteringBRG1, message=FALSE, include=TRUE}
## Select high quality peaks
peaks$BRG1 <- peaks$BRG1[peaks$BRG1$V9 >= 8,]

## Compute the number of remaining peaks
length(peaks$BRG1)
```

## Where are the peaks located over the whole genome?
Sometime, peaks may occur more in some chromosoms than others. We can display the genomic distribution of the peaks along the chromosomes, using the `covplot` function from `ChIPSeeker`. Height of peaks is drawn based on the peak scores.

```{r peakGenomeDistribution, cache=TRUE, include=TRUE}
# genome wide BRG1 peak distribution
covplot(peaks$BRG1, weightCol="V5")

# chromosome wide BRG1 peak distribution
covplot(peaks$BRG1, chrs=c("chr1", "chr2"), weightCol="V5")
```

## Functional annotation: genomic features enriched in BRG1 peaks
### Generate annotation
We can assign peaks to the closest genes and genomic features (introns, exons, promoters, distal regions, etc...).
This is done using the function `annotatePeak` which compares peak positions with the genomic feature positions of the reference genome. This function returns a complex object which contains all this information.

```{r annotatePeaksBRG1, eval=TRUE, message=FALSE, include=TRUE, cache = TRUE}
## org.Hs.eg.db is an R object that contains mappings between Entrez Gene identifiers and GenBank accession numbers.
library(org.Hs.eg.db)

## Annotate peaks for all datasets and store it in a list
## Here TSS regions are regions -1000Kb/+100b arount TSS positions
## Peak annotations are stored in a list
## Load transcript annotation
library(TxDb.Hsapiens.UCSC.hg38.knownGene)
txdb <- TxDb.Hsapiens.UCSC.hg38.knownGene

peakAnno <- list()
peakAnno[["BRG1"]] = annotatePeak(peaks$BRG1, tssRegion=c(-1000, 100), TxDb=txdb, annoDb="org.Hs.eg.db")

## Visualize and export annotation as a data table
# as.data.frame(peakAnno$BRG1)
head(as.data.frame(peakAnno$BRG1))
```

All the peak information contained in the peak list will be retained in the output of `annotatePeak`. The position and strand information of nearest genes are reported. The distance from peak to the TSS of its **nearest gene** is also reported. The genomic region of the peak is reported in annotation column. Since some annotation may overlap, ChIPseeker adopted the following priority in genomic annotation :

  * Promoter
  * 5’ UTR
  * 3’ UTR
  * Exon
  * Intron
  * Downstream
  * Intergenic
  * Downstream is defined as the downstream of gene end.

This hierachy can be customized using the parameter *genomicAnnotationPriority*.

annotatePeak report detail information when the annotation is Exon or Intron, for instance “Exon (uc002sbe.3/9736, exon 69 of 80)”, means that the peak is overlap with an Exon of transcript uc002sbe.3, and the corresponding Entrez gene ID is 9736 (Transcripts that belong to the same gene ID may differ in splice events), and this overlaped exon is the 69th exon of the 80 exons that this transcript uc002sbe.3 prossess.

Parameter annoDb is optional, if provided, extra columns including SYMBOL, GENENAME, ENSEMBL/ENTREZID will be added. The geneId column in annotation output will be consistent with the geneID in TxDb. If it is ENTREZID, ENSEMBL will be added if annoDb is provided, while if it is ENSEMBL ID, ENTREZID will be added.

--
Reminder: The TxDb class is a container for storing transcript annotations.

- Bioconductor provides several packages containing TxDb objects for model organisms sur as Human and mouse. For instance, TxDb.Hsapiens.UCSC.hg38.knownGene, TxDb.Hsapiens.UCSC.hg19.knownGene for human genome hg38 and hg19, TxDb.Mmusculus.UCSC.mm10.knownGene and TxDb.Mmusculus.UCSC.mm9.knownGene for mouse genome mm10 and mm9, etc.

- User can also prepare their own TxDb by retrieving information from UCSC Genome Bioinformatics and BioMart data resources by R function makeTxDbFromBiomart and makeTxDbFromUCSC.

- One can also create a TxDb objects for his favourite organism using an annotation file in GTF/GFF format using the function makeTxDbFromGFF or the package GenomicFeatures.

<details>
  <summary>Expand to find Coturnix japonica example</summary>

```{r createTxDbGTF, include=TRUE, eval=FALSE}
## download GTF file
download.file("https://ftp.ncbi.nlm.nih.gov/genomes/all/annotation_releases/93934/101/GCF_001577835.2_Coturnix_japonica_2.1/GCF_001577835.2_Coturnix_japonica_2.1_genomic.gtf.gz", "Coturnix_japonica_2.1.annotation.gtf.gz")

## Build TxDb object
library(GenomicFeatures)
txdb = makeTxDbFromGFF("Coturnix_japonica_2.1.annotation.gtf.gz")

## To save the txdb database
library(AnnotationDbi)
saveDb(txdb, 'txdb.Coturnix_japonica_2.1.sqlite')

## load it when needed
library(AnnotationDbi)
txdb = loadDb(file = 'txdb.Coturnix_japonica_2.1.sqlite')
```

</details>

--

### Visualize genomic annotation
We can now analyze more in details genomic features associated to our peaks (introns, exons, promoters, distal regions,...).

```{r genomicFeatureDistribution, include=TRUE, eval=TRUE}
## distribution of genomic features for BRG1 peaks
# as a pie chart - which is the most widely used representation in publication
plotAnnoPie(peakAnno$BRG1)

# as a barplot
plotAnnoBar(peakAnno$BRG1)
```

However since some annotation overlap, ChIPseeker provides functions that help having a view of full annotation overlap.
```{r upsetR, include=TRUE, eval=TRUE}
library(UpSetR)
upsetplot(peakAnno$BRG1)
```

### Importance of the annotation database
In the previous section, we have annotated peaks using annotation from UCSC's knownGene. The database chosen for annotation can have an impact on subsequent results including data integration such as comparison between genes associated to peaks and gene expression using RNA-seq data for instance.

Let's look at the overlap between genes expressed in RNA-seq data with genes associated to peaks (let's remind that peaks are associated to closest genes if no other evidences are used).

```{r compareAnnot, include=TRUE, eval=FALSE}
## Download GTF files
library(GenomicFeatures)
## GTF file downloaded from https://ftp.ncbi.nlm.nih.gov/genomes/all/GCA/000/001/405/GCA_000001405.15_GRCh38/seqs_for_alignment_pipelines.ucsc_ids/GCA_000001405.15_GRCh38_full_analysis_set.refseq_annotation.gtf.gz
txdb.refseq = makeTxDbFromGFF("data/GCA_000001405.15_GRCh38_full_analysis_set.refseq_annotation.gtf.gz")
txdb.ensembl = makeTxDbFromGFF("data/Homo_sapiens.GRCh38.103_UCSC_chr.gtf.gz")

## Ensembl TxDB can also been download using the function makeTxDbFromBiomart
# txdb.ensembl <- makeTxDbFromBiomart(biomart="ENSEMBL_MART_ENSEMBL",
  # host="nov2020.archive.ensembl.org", dataset="hsapiens_gene_ensembl")

annot <- list()
annot[["ensembl"]] <- annotatePeak(peaks$BRG1, tssRegion=c(-1000, 100), TxDb=txdb.ensembl, annoDb="org.Hs.eg.db")
annot[["refseq"]] <- annotatePeak(peaks$BRG1, tssRegion=c(-1000, 100), TxDb=txdb.refseq, annoDb="org.Hs.eg.db")

rnaseq <- read.table(paste0(params$path.rnaseq, params$rnaseq), header=TRUE,
          check.names = FALSE, quote="", sep="\t")



```

## Heatmaps: visualisation of binding profiles

Heatmap are widely used representation of ChIP-seq data as it allows visualization of read enrichment at various locations at the same time. For instance, one may want to represent read of its chipped protein enrichment +/-5Kb around all TSS of the reference genome or compare read enrichment at the same locations in many chip-seq datasets.

### BRG1 peak distribution
We want to know if BRG1 is binding large and/or narrow regions, unique and/or tandem etc.

First of all, for calculating the profile of ChIP peaks binding to the BRG1 center, we need to define peak centers and extend them each side. Then align the peaks that are mapped to these regions, and generate the `tagMatrix`.

```{r signalAroundBRG1center, message=FALSE, include=TRUE, cache = TRUE}
## Load the library
library(GenomicRanges)

# Compute the center of the peaks and attribute it to a new
# column in the metadata of the BRG1 peak GRanges
peaks$BRG1$center.peak <- (start(peaks$BRG1) + end(peaks$BRG1))/2

# For computation and memory efficiency reasons,
# we subset the top 10K peaks according to the FDR column (V9)
top.10000 <- peaks$BRG1[order(peaks$BRG1$V9,decreasing=T)][1:10000]

# Generate peak center GRanges for the 10K top peaks
centers.BRG1 <- GRanges(seqnames(top.10000),
                        IRanges(start=top.10000$center.peak,
                                end=top.10000$center.peak))

# Extend each side of 2000 bp
extended.2K.BRG1 <- centers.BRG1
ranges(extended.2K.BRG1) <- IRanges(start=start(centers.BRG1)-2000,
                                    end=end(centers.BRG1)+2000)

## compute the density of peaks within the promoter regions
tagMatrix <- getTagMatrix(peaks$BRG1, windows=extended.2K.BRG1)

## plot the density
tagHeatmap(tagMatrix, xlim=c(-2000, 2000), color="red")
```

The regions are ordered relatively to their peak enrichment.

We can visualize a summary of the binding profiles looking at the corresponding average profile. This kind of profiles is much less greedy, we can extend a bit more (e.g. +/- 5000) from the peak centers redoing the previous steps. Definition of the regions have to be redone. Try to create the `GRanges` and the `tagMatrix`. \

<details>
  <summary>"Click to expand and see the code"</summary>
```{r extend5000, message=FALSE, include=TRUE, cache = TRUE}
# Extend from the peak center
extended.5K.BRG1 <- centers.BRG1
ranges(extended.5K.BRG1) <- IRanges(start=start(centers.BRG1)-5000,
                                    end=end(centers.BRG1)+5000)

## compute the density of peaks within the promoter regions
tagMatrix <- getTagMatrix(peaks$BRG1, windows=extended.5K.BRG1)
```
</details>

\

```{r profileBRG1, message=F,warning=F}
# Plot the profile
plotAvgProf(tagMatrix, xlim=c(-5000, 5000),
            xlab="Distance to peak center", ylab = "Peak Count Frequency")
```


It looks like BRG1 is having several binding patterns but the binary nature of the signal (presence/absence of peaks) and the ordering of the rows do not allow us to appreciate them.

### Read enrichment in BRG1 peaks

For computation and memory efficiency reasons, we are not going to look at read coverage of each position in the regions of interest but they are rather split into non-overlapping equally sized windows. **Thus, we need to build a matrix composed of rows that are all BRG1 peaks and columns that contain read enrichment in all bins.** \

This allows to consider a bigger set of peaks and covered region. We will now analyze the whole set of BRG1 peaks over 10Kb (+/- 5000bp). We will ask for a hundred bins each side of the center resulting in 200 windows of 50 bp.


#### Prepare the signal matrices
We need to load bigwig files for all datasets that we want to visualize.
Data are imported using a function from the `rtracklayer` package.

```{r loadBigwigs, message=FALSE, include=TRUE, cache = TRUE}
# # Generate peak center GRanges for all the peaks
centers.BRG1 <- GRanges(seqnames(peaks$BRG1),
                        IRanges(start=peaks$BRG1$center.peak,
                                end=peaks$BRG1$center.peak))

# Extend each side of 5000 bp
extended.5K.BRG1 <- centers.BRG1
ranges(extended.5K.BRG1) <- IRanges(start=start(centers.BRG1)-5000,
                                    end=end(centers.BRG1)+5000)

# load the library
library(rtracklayer)

# load the bw file for BRG1
cvg.BRG1 <- import(file.path(params$path.bw,params$brg1.bw),format="BigWig",
                      which=extended.5K.BRG1,
                      as="RleList")
cvg.BRG1
```

Now we can create matrix of read enrichments at the positions of interest. We are using functions from `ChIPpeakAnno` package.

```{r prepareMatrix, message=FALSE, include=TRUE}
# load library
library(ChIPpeakAnno)

# featureAlignedSignal needs the coverage (cvg) stored in a list.
cvglist <- list(BRG1=cvg.BRG1)

sig <- featureAlignedSignal(cvglist, centers.BRG1,n.tile=200,
                           upstream=5000, downstream=5000)

dim(sig$BRG1)
```

#### Create heatmaps

Let's draw the heatmaps using the `EnrichedHeatmap` library.
```{r Heatmap, message=FALSE, include=TRUE, cache = TRUE}
## Load the library
library(EnrichedHeatmap)

## Create a list of normalizedMatrix that is the input format
## for EnrichedHeatmap
mat1 <- list()
mat1[["BRG1"]] <- as.normalizedMatrix(as.matrix(sig[["BRG1"]]),
    k_upstream = 100,
    k_downstream = 100,
    k_target = 0,
    extend = c(5000, 5000),
    signal_name = names(sig[["BRG1"]]),
    target_name = "Peak centers"
)

## Create the Heatmap with default parameters
EnrichedHeatmap(mat1$BRG1, name = "BRG1")
```

`EnrichedHeatmap` combines the average profile and the density heatmap. We can observe a greater precision of the signal around the peak centers. As with `ChIPpeakAnno`, by default, heatmaps are sorted by read enrichment. However, it would be worth grouping together regions that have similar read enrichment pattern. This can be done using a clustering method such as k-means. This type of clustering requires the number of expected clusters to be set. Moreover, to obtain reproductible clustering results, we need to set a seed.

```{r Kmeans, message=FALSE, include=TRUE, cache = TRUE}
## define a seed value to get the same results when re-running the analysis
set.seed(123)
## Create Heatmaps with k-means clustering on BRG1 data
## We keep the generated object in order to use the clustering
## information.
heatmap.kmeans <- EnrichedHeatmap(mat1$BRG1, name = "BRG1", row_km = 8,
    column_title = "BRG1", row_title_rot = 0)
## draw the heatmap
draw(heatmap.kmeans)

```

#### Are BRG1 binding profiles associated with particular genomic regions ?

We will use here the clusters obtained with `EnrichedHeatmap` and look at the genomic distribution of peaks using `TxDb.Hsapiens.UCSC.hg38.knownGene` and `plotAnnoBar`.



```{r clusterKmeans, warning=F,message=F, cache = TRUE}
# Use row_order function to retrieve peaks index belonging to each cluster
clusters <- row_order(heatmap.kmeans)
# Check the class and length of the resulting object
class(clusters)
length(clusters)
# Check what is actually in the list elements
head(clusters[[1]])
# Each element of the list contain the indexes of the peaks in the
# original object
# Check cluster sizes
lapply(clusters,length)

# The following code uses each element of the list (peaks indexes)
# to select corresponding peaks in the original data and return them
BRG1.clusters <- lapply(clusters,function(x,peaks){
  # x represents one element of the list, one set of
  # indexes
  cl <- peaks[x]
  return(cl)
},peaks=peaks$BRG1)

# check names of the resulting list
names(BRG1.clusters)

# rename the elements
names(BRG1.clusters) <- paste0("cluster",names(clusters))

# Transform the list as GRangesList to be able to use it with the annotatePeak
# function
BRG1.clusters <- as(BRG1.clusters,"GRangesList")

# apply annotatePeak function to each element of the BRG1.clusters GRangesList
peakAnnoList <- lapply(BRG1.clusters, annotatePeak, TxDb=txdb,
                       tssRegion=c(-1000, 100), annoDb="org.Hs.eg.db",
                       verbose=FALSE)

plotAnnoBar(peakAnnoList)
```

# Data integration: let's compare BRG1 to MITF and SOX10
## Dataset description
### Load MITF and SOX10 datasets
```{r loadData2, include=TRUE}
## Let's load MITF and SOX10 peak sets
peaks[["MITF"]] <- readPeakFile(paste0(params$path.peaks, params$mitf), as="GRanges")
peaks[["SOX10"]] <- readPeakFile(paste0(params$path.peaks, params$sox10), as="GRanges")
```

### How many peaks were called?
Compute the number of datasets.
```{r peaksStats1, include=TRUE}
length(peaks)
```

```{r nbPeaks, include=TRUE}
# Load ggplot2 library
library(ggplot2)

peak.lengths <- data.frame(IP=names(peaks),
                           NbPeaks=sapply(peaks,length))

ggplot(peak.lengths, aes(x=IP, y=NbPeaks, fill=IP)) +
         geom_bar(stat="identity")+
         scale_fill_brewer(palette="Set1")
```

### How large are these peaks?
Compute statistics on all peak sizes

```{r reshapeAll, message=FALSE, include=TRUE}
peak.width = lapply(peaks,width)

peak.width.table <- melt(peak.width)
```

In this table, there is as many rows as the total number of peaks in all peak sets. It contains all possible pairs IP <-> number of peaks possible.
```{r reshapeCheck, message=FALSE, include=TRUE}
# Number of peaks per chipped protein
sapply(peaks, length)
# total number of peaks
sum(sapply(peaks, length))
# size of the table we've just generated
dim(peak.width.table)
```

```{r peakWidthNice, message=FALSE, include=TRUE}
ggplot(peak.width.table, aes(x=L1, y=value, fill=L1)) +
         geom_boxplot()+
         theme_classic()+
         scale_fill_brewer(palette="Set1")+
         labs(x = "", y = "Peak sizes", fill = "")+
         scale_y_log10()
```

## Peak filtering
To make sure we keep only high quality data. We are going to select one those peaks having a qValue >= 4. The qValue corresponds to the 9th column of narrowPeak files. So, we are going to set a threshold on this.

```{r peakFiltering, message=FALSE, include=TRUE}
## Select high quality peaks
peaks <- lapply(peaks, function(x){x[x$V9 >= 4,]})

## Compute the number of remaining peaks
sapply(peaks, length)
```

### Peak annotation
```{r annotatePeaksAll, eval=TRUE, message=FALSE, include=TRUE}
peakAnno[["MITF"]] = annotatePeak(peaks$MITF, tssRegion=c(-1000, 100), TxDb=txdb, annoDb="org.Hs.eg.db")
peakAnno[["SOX10"]] = annotatePeak(peaks$SOX10, tssRegion=c(-1000, 100), TxDb=txdb, annoDb="org.Hs.eg.db")

plotAnnoBar(peakAnno)
```

## Are BRG1, MITF and SOX10 co-localizing ?
### Compare BRG1, MITF and SOX10 peak positions (Venn Diagram)
We can evaluate the peak overlapping with a Venn diagram using the ChIPpeakAnno package.

```{r ovlPeaks, include=TRUE, eval=TRUE,warning=F,message=F}

library(ChIPpeakAnno)
# We first compute the overlap between peak sets, keeping the information
# of all peaks overlapping in each set (see ?findOverlapsOfPeaks for help)
ovl <- findOverlapsOfPeaks(peaks, connectedPeaks="keepAll")

```

ChIPpeakAnno imposes, while plotting the Venn diagram, to compute the significance of the pairwise associations using a hypergeometric test. To this end, we need to estimate the number of all potential binding events which is used by the `makeVennDiagram` function through the `totalTest` number. It is used for the hypergeometric sampling that is used to determine if the overlap between two datasets is more than would be expected by chance. This is not a trivial question, the answer is driven by what you know about the binding properties of your factors (eg. sequence specific, mainly intergenic etc). You can find an interesting discussion [here](https://stat.ethz.ch/pipermail/bioconductor/2010-November/036540.html).
In our case we can refer to the genomic distribution of the peaks that we have plotted previously. We can assume that our TFs have a gene body binding preference. Genes cover roughly 10% of the genome.

```{r defineHyperTot, include=TRUE, eval=TRUE,warning=F,message=F}
# Estimate the average size of the peaks ...
averagePeakWidth <- mean(width(unlist(GRangesList(ovl$peaklist))))

# ... to count how many potential sites could have been bound in coding regions.
tot <- ceiling(3.3e+9 * 0.1 / averagePeakWidth)
```

We will define the colors attributed to each set using the function `colours()`. In any case you want to set a color you can use this function.

<!-- ![R chart colours](/Users/elodiedarbo/Documents/file_general/R_chart_colors.png) -->

```{r VennAnno, fig.width=8,fig.height=8,warning=F,message=F}
fill.colors <- c(BRG1=colours()[373],MITF=colours()[591],SOX10=colours()[102])
circle.font.colors <- c(BRG1=colours()[35],MITF=colours()[618],SOX10=colours()[614])

makeVennDiagram(ovl, totalTest=tot, connectedPeaks="keepAll",
                fill=fill.colors, # circle fill color
                col=circle.font.colors, #circle border color
                cat.col=circle.font.colors)
```

According to the hypergeometric test p-values all pairwise comparisons are highly significant (=0). This has to be taken very carefully as it depends largely on the background estimation that we may have over-estimated. If you are not sure about your estimation, you will prefer to use a non-parametric approach based on your peak genomic distribution to estimate randomness. To this end the `TxDb.Hsapiens.UCSC.hg38.knownGene` is used.

#### Is the overlap significant?
ChIPpeakAnno provides the `preparePool` and `peakPermTest` functions to compute this test. These tests are made by pair, we will look at SOX10/MITF overlap significance as an example.

```{r permPeaks, warning=F,message=F}

# Prepare a pool of random peaks following the characteristics of our peak sets
pool <- preparePool(txdb,peaks$SOX10,bindingType="TSS",featureType="transcript",seqn=paste0("chr",c(1:22,"X","Y")))
# Create the permPool object needed for peakPermTest
pool <- new("permPool",grs=pool$grs[1],N=length(peaks$SOX10))
SOX10.MITF <- peakPermTest(peaks$SOX10, peaks$MITF, pool=pool, seed=1, force.parallel=FALSE)
SOX10.MITF
plot(SOX10.MITF)
```

Venn diagrams are widely used to represent overlaps, intersections. However, in ChIP-seq analysis, the definition of the peaks is dependent on the peak caller, the FDR thresholds (what about peaks just bellow the threshold). The overlap is also difficult to assess, indeed do we call an overlap a 1 nucleotide an intersection ? It is one of the numerous parameters that can be tuned ...

Are different combinations of TFs bind specific genomic regions ?

```{r}
coocs <- as(ovl$peaklist,"GRangesList")
peakAnnoList <- lapply(coocs, annotatePeak, TxDb=txdb,
                        tssRegion=c(-1000, 100), annoDb="org.Hs.eg.db",
                        verbose=FALSE)
plotAnnoBar(peakAnnoList)
plotDistToTSS(peakAnnoList)
```

### Heatmaps / Profiles

One way to circumvent hard thresholds and relatively arbitrary choices, we can choose to use heatmap and average profile representations. To this end, we need to define the reference point of view. We use the BRG1 peak centers.

Load bigwig file for MITF and SOX10 **at BRG1 peaks**.

```{r cvglistPlus, warning=F,message=F, cache = TRUE}
cvglist$MITF <- import(file.path(params$path.bw,params$mitf.bw),format="BigWig",
                      which=extended.5K.BRG1,
                      as="RleList")
cvglist$SOX10 <- import(file.path(params$path.bw,params$sox10.bw),format="BigWig",
                      which=extended.5K.BRG1,
                      as="RleList")
```

Prepare the matrices binned in 50bp windows.

```{r prepareMatrices, message=FALSE, include=TRUE}
sig <- featureAlignedSignal(cvglist, centers.BRG1,
                           upstream=5000, downstream=5000,n.tile=200)

lapply(sig, dim)
```

Create normalized matrices.

```{r CreateTSSNorm, warning=F,message=F}
## Create a list of normalizedMatrix that is the input format
## for EnrichedHeatmap

BRG1.mat <- lapply(sig, function(x){
  # x represent each element of the sig list
  mat <- as.normalizedMatrix(as.matrix(x),
                      k_upstream = 100,
                      k_downstream = 100,
                      k_target = 0,
                      extend = c(5000, 5000),
                      #signal_name = names(sig[["MITF"]]),
                      target_name = "Peak center"
                      )
  return(mat)
})
```

Create heatmap with K-means clustering.

```{r TSSheatmapKmeans, message=F,warning=F, cache = TRUE}
## Create the Heatmap with default parameters
multi.heatmap <- EnrichedHeatmap(BRG1.mat$BRG1, name = "BRG1", row_km = 8,
    column_title = "BRG1", row_title_rot = 0) +
EnrichedHeatmap(BRG1.mat$MITF, name = "MITF",
    column_title = "MITF") +
EnrichedHeatmap(BRG1.mat$SOX10, name = "SOX10",
    column_title = "SOX10")

htlist <- draw(multi.heatmap)
```

Let's enhance it!

```{r enhancedHeatmap, message=FALSE, include=TRUE}
library(circlize)
# we retrieve the cluster information from the previous command
clusters <- row_order(htlist)
# rename the clusters
names(clusters) <- paste0("cluster",names(clusters))
# transform to a vector
clusters <- unlist(clusters)
head(clusters)
# names of the elements were extended with a number
# We thus trim them to retrieve the cluster name
names(clusters) <- substring(first = 1,last = 8,text=names(clusters))

# The numbers are the indexes of the rows, we need to
# sort the indexes to get the right order of cluster
# labels
partition <- names(clusters)[order(clusters)]
# Define new colors for each heatmap
col_sox10 <-colorRamp2(c(0,2,3), c("white", "blue","black"))
col_mitf <- colorRamp2(c(0,4,5), c("white", "blue","black"))
col_brg1 <- colorRamp2(c(0,5,6), c("white", "blue","black"))
# create a legend for the cluster labels
lgd <- Legend(at = c("cluster1", "cluster2", "cluster3", "cluster4","cluster5","cluster6","cluster7","cluster8"),
    title = "Clusters",
    type = "lines", legend_gp = gpar(col = 2:9))

# Add a first column containing the cluster assignment
ht_list <- Heatmap(partition, col = structure(2:9, names = paste0("cluster", 1:8)), name = "partition", show_row_names = FALSE, width = unit(3, "mm")) +
EnrichedHeatmap(BRG1.mat$BRG1, name = "BRG1", col=col_brg1,
  top_annotation = HeatmapAnnotation(lines = anno_enriched(gp = gpar(col = 2:9))),
  column_title = "BRG1") +
EnrichedHeatmap(BRG1.mat$MITF, name = "MITF",
  top_annotation = HeatmapAnnotation(lines = anno_enriched(gp = gpar(col = 2:9))),
  column_title = "MITF", row_title_rot = 0, col=col_mitf) +
EnrichedHeatmap(BRG1.mat$SOX10, name = "SOX10",
  top_annotation = HeatmapAnnotation(lines = anno_enriched(gp = gpar(col = 2:9))),
  column_title = "SOX10", row_title_rot = 0, col=col_sox10)

draw(ht_list, split = partition, annotation_legend_list = list(lgd),
    ht_gap = unit(c(2, 8, 8,8), "mm"))

```

## Is gene expression influenced by TF binding to their promoters ?

Select genes having BRG1 binding close to their TSS. To do that we will plot a heatmap centered on TSS.

```{r loadBigwigs2, message=FALSE, warning=FALSE, include=TRUE}
# load the library
library(GenomicFeatures)

# Generate TSS and promoter GRanges, the function promoters allows to retrieve the
# gene ID (entrez)
TSS <- GenomicFeatures::promoters(txdb, upstream=0, downstream=0, columns="gene_id")
TSS.extended <- GenomicFeatures::promoters(txdb, upstream=2000, downstream=2000, columns="gene_id")
TSS.extended

# The column gene_id is of type characterList, this type is difficult to
# manipulate. We then decide to transform it to a character vector
gene_ids <- unlist(lapply(TSS$gene_id,function(x){
  if (length(x)==0){
     NA
  }
  else {
    x
  }
} ))

# Keep TSS on selected chromosomes annotated with a gene ID and remove
# duplicate IDs due to transcript isoforms. Here, the selection of the
# isoform is random.
TSS <- TSS[as.vector(seqnames(TSS))%in%paste0("chr",c(1:22,"X","Y")) & !is.na(gene_ids) & !duplicated(gene_ids)]
TSS.extended <- TSS.extended[as.vector(seqnames(TSS.extended))%in%paste0("chr",c(1:22,"X","Y")) & !is.na(gene_ids) & !duplicated(gene_ids)]

# load the bw file for all TFs within the promoter
cvglist <- list()
cvglist$BRG1 <- import(file.path(params$path.bw,params$brg1.bw),format="BigWig",
                      which=TSS.extended,
                      as="RleList")
cvglist$MITF <- import(file.path(params$path.bw,params$mitf.bw),format="BigWig",
                      which=TSS.extended,
                      as="RleList")
cvglist$SOX10 <- import(file.path(params$path.bw,params$sox10.bw),format="BigWig",
                      which=TSS.extended,
                      as="RleList")

# Produce the signal matrices
sig <- featureAlignedSignal(cvglist, TSS,n.tile=400,
                           upstream=2000, downstream=2000)


# Transform the signal matrices as normalizedMatrix
TSS.mat <- lapply(sig, function(x){
  # x represent each element of the sig list
  mat <- as.normalizedMatrix(as.matrix(x),
                      k_upstream = 200,
                      k_downstream = 200,
                      k_target = 0,
                      extend = c(2000, 2000),
                      target_name = "TSS"
                      )
  return(mat)
})

# Cmpute a partition using the kmeans function, asking for 5 clusters
set.seed(20210526)
partition = paste0("cluster", kmeans(TSS.mat$BRG1, centers = 5)$cluster)

# Specify colors for the position enrichment for each matrix
col_sox10 = colorRamp2(c(0,3,4), c("white", "blue","black"))
col_mitf = colorRamp2(c(0,4,5), c("white", "blue","black"))
col_brg1 = colorRamp2(c(0,5,6), c("white", "blue","black"))
lgd = Legend(at = c("cluster1", "cluster2", "cluster3", "cluster4","cluster5"),
    title = "Clusters",
    type = "lines", legend_gp = gpar(col = 2:6))


ht_list = Heatmap(partition, col = structure(2:7, names = paste0("cluster", 1:5)), name = "partition", show_row_names = FALSE, width = unit(3, "mm")) +
EnrichedHeatmap(TSS.mat$BRG1, name = "BRG1", col=col_brg1,
  top_annotation = HeatmapAnnotation(lines = anno_enriched(gp = gpar(col = 2:6))),
  column_title = "BRG1") +
EnrichedHeatmap(TSS.mat$MITF, name = "MITF",
  top_annotation = HeatmapAnnotation(lines = anno_enriched(gp = gpar(col = 2:6))),
  column_title = "MITF", row_title_rot = 0, col=col_mitf) +
EnrichedHeatmap(TSS.mat$SOX10, name = "SOX10",
  top_annotation = HeatmapAnnotation(lines = anno_enriched(gp = gpar(col = 2:6))),
  column_title = "SOX10", row_title_rot = 0, col=col_sox10)

draw(ht_list, split = partition, annotation_legend_list = list(lgd),
    ht_gap = unit(c(2, 8, 8,8), "mm"))

```

Lets' integrate expression data from RNA-seq experiment. RNA-seq data were preprocessed, normalized and called for differentially expressed genes.

The goal of the following code is to visualise the gene expression according to the cluster the TSS belong. To this end, we will need to play with identifiers from different databases.

```{r, cache = TRUE}
# load RNA-seq normalized expression data
load(params$rnaseq) # RNAseq

head(RNAseq)

# Convert The ENSEMBL IDs from the RNAseq into ENTREZID to be able to
# map the clusters from the heatmap with the corresponding expression.
# We use an OrgDB object for the human genome
# the available information are displayed using columns()
columns(org.Hs.eg.db)

conv <- mapIds(x=org.Hs.eg.db,
              keys=RNAseq$Ensembl.Gene.ID, # what do we want to be mapped
              column="ENTREZID", # which type of ID we want
              keytype="ENSEMBL") # what type of ID we give
head(conv)
# names of the vector are ENSEMBL IDs and elements are ENTREZ IDs
# The match function allows to return match between the IDs in RNAseq
# and the ENSEMBL IDs from the conversion vector
m <- match(RNAseq$Ensembl.Gene.ID,names(conv))
head(m)
# m contains NA for element in the first vector not present in the 2nd
# or the index of the element of the 2nd vector corresponding the those
# in the first
# Attribute the matched ENTREZ ID
RNAseq$ENTREZID <- conv[m]


# We add the partition (clusters) to the TSS object in order to add the
# clusters to the RNA-seq object
TSS$cluster <- partition

# The common IDs this time are the ENTREZ IDs
m <- match(RNAseq$ENTREZID,unlist(TSS$gene_id))
RNAseq$cluster <- TSS$cluster[m]

# visualise distributions with ggplot2
library(ggplot2)

# distribution of gene expression in clusters using boxplots
# in wild type cell
ggplot(RNAseq,aes(x=cluster,y=log2(WT.norm+1))) +
  geom_boxplot() +
  theme_bw()

# in cell with a BRG1 KD
ggplot(RNAseq,aes(x=cluster,y=log2(shBGR1.norm+1))) +
  geom_boxplot() +
  theme_bw()

# Distribution of differentially expressed genes as barplots
ggplot(RNAseq,aes(x=cluster)) +
  geom_bar(aes(fill=signif),position = "fill",color="black") +
  theme_bw() +
  scale_fill_manual(values=c(up="red",down="blue",stable="white"))

```

## Are the differentially expressed genes with different BRG1 binding patterns have different biological function ?

```{r funcEnr, message=F,warning=F, cache = TRUE}

library(clusterProfiler)
geneList <- RNAseq[RNAseq$signif!="stable",]
geneList <- split(geneList$ENTREZID,geneList$cluster)
compKEGG <- compareCluster(geneCluster   = geneList,
                         fun           = "enrichKEGG",
                         pvalueCutoff  = 0.05,
                         pAdjustMethod = "BH")
dotplot(compKEGG, showCategory = 15, title = "KEGG Pathway Enrichment Analysis")

```

### Are there published data I could use to enrich my analysis ?

- Data Mining with ChIP seq data deposited in GEO with `ChIPSeeker`

There are many ChIP seq data sets that have been published and deposited in GEO database. We can compare our own dataset to those deposited in GEO to search for significant overlap data. Significant overlap of ChIP seq data by different binding proteins may be used to infer cooperative regulation and thus can be used to generate hypotheses.

We collect about 17,000 bed files deposited in GEO, user can use getGEOspecies to get a summary based on spieces.

```{r geospecies, message=F,warning=F}
getGEOspecies()
```

User can access the detail information by getGEOInfo, for each genome version.

```{r}
hg38 <- getGEOInfo(genome="hg38", simplify=TRUE)
head(hg38)
```

ChIPseeker provide function downloadGEObedFiles to download all the bed files of a particular genome.

```{r, eval=F}
downloadGEObedFiles(genome="hg38", destDir="hg38")
```

Or a vector of GSM accession number by downloadGSMbedFiles.

```{r, eval=F}
gsm <- hg38$gsm[sample(nrow(hg38), 10)]
downloadGSMbedFiles(gsm, destDir="hg38")
```

After download the bed files from GEO, we can pass them to `enrichPeakOverlap` for testing the significant of overlap. Parameter targetPeak can be the folder, e.g. hg19, that containing bed files. `enrichPeakOverlap` will parse the folder and compare all the bed files. It is possible to test the overlap with bed files that are mapping to different genome or different genome versions, `enrichPeakOverlap` provide a parameter `chainFile` that can pass a chain file and liftOver the `targetPeak` to the genome version consistent with `queryPeak.` Signifcant overlap can be use to generate hypothesis of cooperative regulation.By mining the data deposited in GEO, we can identify some putative complex or interacted regulators in gene expression regulation or chromosome remodelling for further validation.

- The (mod)ENCODE project [link](https://www.encodeproject.org/chip-seq-matrix/?type=Experiment&replicates.library.biosample.donor.organism.scientific_name=Homo%20sapiens&assay_title=TF%20ChIP-seq&status=released)

- The UCSC genome browser [link](https://genome-euro.ucsc.edu/cgi-bin/hgGateway?redirect=manual&source=genome.ucsc.edu)

# Session info
```{r sessionInfo, include=TRUE, eval=TRUE}
sessionInfo()
```

# References
