---
title: "EBAIIn2 - ChIP-seq Workshop - Heatmaps"
date: "2021 May, 27th"
output:
  html_document:
    fig_caption: yes
    toc: true
    toc_depth: 4
  pdf_document:
    fig_caption: yes
    keep_tex: yes
    toc: true
    toc_depth: 3
params:
  ensembl: 103
  assembly: hg38
  organism: Homo sapiens
  <!-- path.peaks: /Volumes/ngs/illumina/slegras/B21000_EBAIIv2/2021-05-07_PeakCalling/ -->
  path.peaks: /Users/slegras/Documents/Formations/EBAII/2021/ebaiin2/chip-seq/data/
  brg1: BRG1siCTRL_CHIP-seq_peaks.narrowPeak
  mitf: MITF_CHIP-seq_peaks.narrowPeak
  sox10: SOX10_CHIP-seq_peaks.narrowPeak
  <!-- path.bw: /Volumes/ngs/illumina/slegras/B21000_EBAIIv2/2021-05-10_bigWigs/ -->
  path.bw: /Users/slegras/Documents/Formations/EBAII/2021/ebaiin2/chip-seq/data/
  brg1.bw: BRG1siCTRL_CHIP-seq.bw
  mitf.bw: MITF_CHIP-seq.bw
  sox10.bw: SOX10_CHIP-seq.bw
bibliography: references.bib
---

```{r setup, include=FALSE}
knitr::opts_knit$set(echo = TRUE,  root.dir="/Users/slegras/Documents/Formations/EBAII/2021/ebaiin2/chip-seq/", fig.path = "images/")
```

## Heatmaps
Heatmap are widely used representation of ChIP-seq data as it allows visualization of read enrichment at various locations at the same time. For instance, one may want to represent read of its chipped protein enrichment +/-5Kb around all TSS of the reference genome or compare read enrichment at the same locations in many chip-seq datasets.

### Visualize BRG1 read enrichment at TSS
We can check if there is a tendency for the peaks to be located close to gene promoters. Here promoters are defined as regions +/-2Kb around the TSS.

First of all, for calculating the profile of ChIP peaks binding to TSS regions, we should prepare the TSS regions, which are defined as the flanking sequence of the TSS sites. Then align the peaks that are mapped to these regions, and generate the tagMatrix.
```{r signalAroundTSS, message=FALSE, include=TRUE}
## Load transcript annotation
library(TxDb.Hsapiens.UCSC.hg38.knownGene)
txdb <- TxDb.Hsapiens.UCSC.hg38.knownGene

## Load peaks
library(ChIPseeker)

peaks <- list()
peaks[["BRG1"]] <- readPeakFile(paste0(params$path.peaks, params$brg1), as="GRanges")

## define gene promoters
## TxDb object should be passed for peak annotation (see below)
promoter = getPromoters(TxDb=txdb, upstream=2000, downstream=2000)

## compute the density of peaks within the promoter regions
tagMatrix <- getTagMatrix(peaks$BRG1, windows=promoter)

## plot the density
tagHeatmap(tagMatrix, xlim=c(-2000, 2000), color="red")
```

Now look at the corresponding average profile.
```{r averageProfile, message=FALSE, include=TRUE}
plotAvgProf2(peaks, TxDb=txdb, upstream=5000, downstream=5000,
             xlab="Genomic Region (5'->3')", ylab = "Read Count Frequency")
```

### Are MITF and BRG1 co-localizing at MITF peak locations
To address this question, we are going to compute and visualize read enrichment at MITF peak location. Most of the time we look at regions centered at middles of peaks of interest and extended to 2/5Kb in both direction.
To achieve this, we need :

  * MITF peaks (narrowPeak file format)
  * Signal tracks such as BigWig files for all datasets we want to visualize.

For computation and memory efficiency reasons, we are not going to look at read coverage of each nucleotide in the regions of interest but they are rather split into non-overlapping 50nt long windows. **Thus, we need to build a matrix composed of rows that are all MITF peaks and columns that contain read enrichment in all 50nt.**

#### Prepare reference coordinates
We first need to load MITF peaks.
```{r loadPeaks, message=FALSE, include=TRUE}
## Loading peaks
peaks[["MITF"]] <- readPeakFile(paste0(params$path.peaks, params$mitf), as="GRanges")
```

Now, we prepare a GRange object that contains the regions of interest *i.e* positions of MITF peak centers +/-2Kb.

```{r prepareRef, message=FALSE, include=TRUE}
features <- peaks$MITF
wid <- width(features)
feature.recentered <- feature.center <- features
start(feature.center) <- start(features) + floor(wid/2)
width(feature.center) <- 1
start(feature.recentered) <- start(feature.center) - 2000
end(feature.recentered) <- end(feature.center) + 2000
```

#### Prepare the signal matrices
We need to load bigwig files for all datasets that we want to visualize.
Data are imported using a function from the rtracklayer package.
```{r loadBigwigs, message=FALSE, include=TRUE}
library(rtracklayer)

cvglists <- sapply(file.path(params$path.bw,
                           c(params$brg1.bw, params$mitf.bw)),
                      import,
                      format="BigWig",
                      which=feature.recentered,
                      as="RleList")

cvglists

## You can notice that names of entries in cvglists are full path to the data
## We are going to give shorter names
## if you know the order of each entry, you can set them like:
names(cvglists) <- c("BRG1", "MITF")

```
<!-- # load the ChIPpeakAnno library


# ## With ChIPpeakAnno package
# heatmap <- featureAlignedHeatmap(sig, feature.center,
#                                  upstream=2000, downstream=2000,
#                                  upper.extreme=c(3,.5,4))
#
# featureAlignedDistribution(sig, feature.center,
#                           upstream=2000, downstream=2000,
#                           type="l") -->

Now we can create matrices of read enrichments at the positions of interest. We are using functions from ChIPpeakAnno.

```{r prepareMatrix, message=FALSE, include=TRUE}
library(ChIPpeakAnno)
sig <- featureAlignedSignal(cvglists, feature.recentered,
                           upstream=2000, downstream=2000)

lapply(sig, head)
```

#### Create heatmaps
Let's draw the heatmaps using the EnrichedHeatmap library.
```{r Heatmap, message=FALSE, include=TRUE}
## Load the library
library(EnrichedHeatmap)

## Create a list of normalizedMatrix that is the input format
## for EnrichedHeatmap
mat1 <- list()
mat1[["MITF"]] <- as.normalizedMatrix(as.matrix(sig[["MITF"]]),
    k_upstream = 50,
    k_downstream = 50,
    k_target = 0,
    extend = c(2000, 2000),
    signal_name = names(sig[["MITF"]]),
    target_name = "Peak centers"
)

mat1[["BRG1"]] <- as.normalizedMatrix(as.matrix(sig[["BRG1"]]),
    k_upstream = 50,
    k_downstream = 50,
    k_target = 0,
    extend = c(2000, 2000),
    signal_name = names(sig[["BRG1"]]),
    target_name = "Peak centers"
)

## Create the Heatmap with default parameters
EnrichedHeatmap(mat1$MITF, name = "MITF") +
EnrichedHeatmap(mat1$BRG1, name = "BRG1")
```

By default, heatmaps are sorted by read enrichment. However, it would be worth grouping together regions that have similar read enrichment. This can be done using a clustering method such as k-means. This type of clustering requires the number of expected clusters to be set. Moreover, to obtain reproductible clustering results, we need to set a seed.

```{r Kmeans, message=FALSE, include=TRUE}
## define a seed value to get the same results when re-running the analysis
set.seed(123)
## Create Heatmaps with k-means clustering on MITF data
EnrichedHeatmap(mat1$MITF, name = "MITF", row_km = 4,
    column_title = "MITF", row_title_rot = 0) +
EnrichedHeatmap(mat1$BRG1, name = "BRG1",
    column_title = "BRG1")
```

Let's enhance it!
```{r enhancedHeatmap, message=FALSE, include=TRUE}
library(circlize)
partition = paste0("cluster", kmeans(mat1$MITF, centers = 4)$cluster)
col_mitf = colorRamp2(c(0, 20), c("white", "blue"))
col_brg1 = colorRamp2(c(0, 6), c("white", "blue"))
lgd = Legend(at = c("cluster1", "cluster2", "cluster3", "cluster4"),
    title = "Clusters",
    type = "lines", legend_gp = gpar(col = 2:5))

ht_list = Heatmap(partition, col = structure(2:5, names = paste0("cluster", 1:4)), name = "partition", show_row_names = FALSE, width = unit(3, "mm")) +
EnrichedHeatmap(mat1$MITF, name = "MITF",
  top_annotation = HeatmapAnnotation(lines = anno_enriched(gp = gpar(col = 2:5))),
  column_title = "MITF", row_title_rot = 0, col=col_mitf) +
EnrichedHeatmap(mat1$BRG1, name = "BRG1", col=col_brg1,
  top_annotation = HeatmapAnnotation(lines = anno_enriched(gp = gpar(col = 2:5))),
  column_title = "BRG1")

draw(ht_list, split = partition, annotation_legend_list = list(lgd),
    ht_gap = unit(c(2, 8, 8), "mm"))

```

### session info
```{r sessionInfo, include=TRUE, eval=TRUE}
sessionInfo()
```
