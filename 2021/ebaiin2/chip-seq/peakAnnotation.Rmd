---
title: "EBAIIn2 - ChIP-seq Workshop - Peak annotation"
date: "2021 May"
author: "Elodie Darbo$^{1}$ - elodie.darbo@u-bordeaux.fr; Stephanie Le Gras$^{2}$ - slegras@igbmc.fr"
output:
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
    number_sections: true
  pdf_document:
    fig_caption: yes
    keep_tex: yes
    toc: true
    toc_depth: 4
params:
  path.peaks: /Users/slegras/Documents/Formations/EBAII/2021/ebaiin2/chip-seq/data/
  brg1: BRG1siCTRL_CHIP-seq_peaks.narrowPeak
  mitf: MITF_CHIP-seq_peaks.narrowPeak
  sox10: SOX10_CHIP-seq_peaks.narrowPeak
  ensembl: 103
  assembly: hg38
  organism: Homo sapiens
  rnaseq: B21000_alldata.tsv
  path.rnaseq: /Users/slegras/Documents/Formations/EBAII/2021/ebaiin2/chip-seq/data/
bibliography: references.bib
---

```{r setup, include=FALSE}
knitr::opts_knit$set(echo = TRUE,  root.dir="/Users/slegras/Documents/Formations/EBAII/2021/ebaiin2/chip-seq/", fig.path = "images/")
```

$^1$

$^2$ GenomEast platform, IGBMC

## Peak annotation
### Load data
Peak files are in narrowPeak format which is of the form ([source](https://genome.ucsc.edu/FAQ/FAQformat.html#format12)):

1. chrom - Name of the chromosome (or contig, scaffold, etc.).
2. chromStart - The starting position of the feature in the chromosome or scaffold. The first base in a chromosome is numbered 0.
3. chromEnd - The ending position of the feature in the chromosome or scaffold. The chromEnd base is not included in the display of the feature. For example, the first 100 bases of a chromosome are defined as chromStart=0, chromEnd=100, and span the bases numbered 0-99.
4. name - Name given to a region (preferably unique). Use "." if no name is assigned.
5. score - Indicates how dark the peak will be displayed in the browser (0-1000). If all scores were "'0"' when the data were submitted to the DCC, the DCC assigned scores 1-1000 based on signal value. Ideally the average signalValue per base spread is between 100-1000.
6. strand - +/- to denote strand or orientation (whenever applicable). Use "." if no orientation is assigned.
7. signalValue - Measurement of overall (usually, average) enrichment for the region.
8. pValue - Measurement of statistical significance (-log10). Use -1 if no pValue is assigned.
9. qValue - Measurement of statistical significance using false discovery rate (-log10). Use -1 if no qValue is assigned.
10. peak - Point-source called for this peak; 0-based offset from chromStart. Use -1 if no point-source called.

```{r loadData, include=TRUE}
## The package ChIPseeker provides a function to load peak files such as narrowPeaks as GRanges objects
## Here all peak sets are loaded into a list of peaks
library(ChIPseeker)

peaks <- list()
peaks[["BRG1"]] <- readPeakFile(paste0(params$path.peaks, params$brg1), as="GRanges")
peaks[["MITF"]] <- readPeakFile(paste0(params$path.peaks, params$mitf), as="GRanges")
peaks[["SOX10"]] <- readPeakFile(paste0(params$path.peaks, params$sox10), as="GRanges")
peaks
```

Peaks are stored as **GenomicRanges** objects; this is an R format which look like the bed format, but is optimized in terms of memory requirements and speed of execution.

We can start by computing some basic statistics on the peak sets.

### Statistics on peak sets
#### How many peaks were called?
Compute the number of datasets.
```{r peaksStats1, include=TRUE}
length(peaks)
```

Compute the number of peaks per dataset.
```{r peaksStats2, include=TRUE}
# sapply() function takes list, vector or data frame as input and gives output in vector or matrix
# sapply apply the same function (here length) to all elements
# of the list "peaks"
sapply(peaks,length)
```

Make a simple barplot showing the number of peaks per chipped protein.
```{r simplebarplot, include=TRUE}
barplot(sapply(peaks,length))
```

Let's create a barplot with ggplot2 out of this data.
```{r enhancedbarplot, include=TRUE}
# Load ggplot2 library
library(ggplot2)

# create a table with the data to display
peak.lengths <- data.frame(IP=names(peaks),
                           NbPeaks=sapply(peaks,length))

# make the barplot
ggplot(peak.lengths, aes(x=IP, y=NbPeaks)) +
         geom_bar(stat="identity")

# Let's add colors to the barplot
# In R it exists some already defined colors palettes
# the most widely used palette is RColorBrewer.
# This R library offers several color palettes
# See:
library(RColorBrewer)
par(mar=c(3,4,2,2))
display.brewer.all()

# now lets add colors to the barplot
# first ass the new information, fill=IP to let ggplot know
# that colors change based on chipped protein
ggplot(peak.lengths, aes(x=IP, y=NbPeaks, fill=IP)) +
         geom_bar(stat="identity")

# if we want to use colors from RColorBrewer library
# with the "Set1" color palette
ggplot(peak.lengths, aes(x=IP, y=NbPeaks, fill=IP)) +
         geom_bar(stat="identity")+
         scale_fill_brewer(palette="Set1")
```

#### How large are these peaks?
Compute statistics on BRG1 peak sizes
```{r peakWidth, message=FALSE, include=TRUE}
## we use the function width() from GenomicRanges
library(GenomicRanges)
summary(width(peaks$BRG1))
```

Now, get the same for all peaks.
```{r peakWidth, message=FALSE, include=TRUE}
## lapply() function is useful for performing operations on list objects and returns a list object of same length of original set.
peak.width = lapply(peaks,width)
lapply(peak.width,summary)
```

Create a simple boxplot of the peak sizes.
```{r simpleboxplot, message=FALSE, include=TRUE}
boxplot(peak.width)
```

Now, create a nice looking boxplot with ggplot2. ggplot takes a data frame as input. We can either create a date frame, this is what we have done when we created the barplot. Here, we are going to use a package that creates a data frame from other types of data: reshape2.
```{r reshape, message=FALSE, include=TRUE}
# Load the package
library(reshape2)
peak.width.table <- melt(peak.width)
head(peak.width.table)
```

In this table, there is as many rows as the total number of peaks in all peak sets. It contains all possible pairs IP <-> number of peaks possible.
```{r reshapeCheck, message=FALSE, include=TRUE}
# Number of peaks per chipped protein
sapply(peaks, length)
# total number of peaks
sum(sapply(peaks, length))
# size of the table we've just generated
dim(peak.width.table)
```

Now create a nice looking boxplot.
```{r enhancedboxplot1, message=FALSE, include=TRUE}
ggplot(peak.width.table, aes(x=L1, y=value)) +
         geom_boxplot()
```

Enhance it.
```{r enhancedboxplot2, message=FALSE, include=TRUE}
# - theme_classic() change grey background to white background
# - fill=L1 and scale_fill_brewer(palette="Set1") colors boxplots
# based on chipped protein and with colors from RColorBrewer Set1 palette
# - labs changes x and y axis labels and legend title
# - scale_y_log10() set y axis to a log scale so that we can have a nice
# view of the data in small values
ggplot(peak.width.table, aes(x=L1, y=value, fill=L1)) +
         geom_boxplot()+
         theme_classic()+
         scale_fill_brewer(palette="Set1")+
         labs(x = "", y = "Peak sizes", fill = "")+
         scale_y_log10()

```

### Where are the peaks located over the whole genome?
Sometime, peaks may occur more in some chromosoms than others. We can display the genomic distribution of the peaks along the chromosomes, using the `covplot` function from `ChIPSeeker`. Height of peaks is drawn based on the peak scores.

```{r peakGenomeDistribution, include=TRUE}
# genome wide BRG1 peak distribution
covplot(peaks$BRG1, weightCol="V5")

# chromosome wide BRG1 peak distribution
covplot(peaks$BRG1, chrs=c("chr1", "chr2"), weightCol="V5")
```

### Functional annotation
We can now assign peaks to the closest genes and genomic features (introns, exons, promoters, distal regions, etc...).
This is done using the function `annotatePeak` which compares peak positions with the genomic feature positions of the reference genome. This function returns a complex object which contains all this information.

```{r annotatePeaks, eval=TRUE, message=FALSE, include=TRUE}
## org.Hs.eg.db is an R object that contains mappings between Entrez Gene identifiers and GenBank accession numbers.
library(org.Hs.eg.db)

## Annotate peaks for all datasets and store it in a list
## Here TSS regions are regions -1000Kb/+100b arount TSS positions
## Peak annotations are stored in a list
## Load transcript annotation
library(TxDb.Hsapiens.UCSC.hg38.knownGene)
txdb <- TxDb.Hsapiens.UCSC.hg38.knownGene

peakAnno <- list()
peakAnno[["BRG1"]] = annotatePeak(peaks$BRG1, tssRegion=c(-1000, 100), TxDb=txdb, annoDb="org.Hs.eg.db")
peakAnno[["MITF"]] = annotatePeak(peaks$MITF, tssRegion=c(-1000, 100), TxDb=txdb, annoDb="org.Hs.eg.db")
peakAnno[["SOX10"]] = annotatePeak(peaks$SOX10, tssRegion=c(-1000, 100), TxDb=txdb, annoDb="org.Hs.eg.db")

## Visualize and export annotation as a data table
# as.data.frame(peakAnno$BRG1)
head(as.data.frame(peakAnno$BRG1))
```

All the peak information contained in the peak list will be retained in the output of `annotatePeak`. The position and strand information of nearest genes are reported. The distance from peak to the TSS of its **nearest gene** is also reported. The genomic region of the peak is reported in annotation column. Since some annotation may overlap, ChIPseeker adopted the following priority in genomic annotation :

  * Promoter
  * 5’ UTR
  * 3’ UTR
  * Exon
  * Intron
  * Downstream
  * Intergenic
  * Downstream is defined as the downstream of gene end.

This hierachy can be customized using the parameter *genomicAnnotationPriority*.

annotatePeak report detail information when the annotation is Exon or Intron, for instance “Exon (uc002sbe.3/9736, exon 69 of 80)”, means that the peak is overlap with an Exon of transcript uc002sbe.3, and the corresponding Entrez gene ID is 9736 (Transcripts that belong to the same gene ID may differ in splice events), and this overlaped exon is the 69th exon of the 80 exons that this transcript uc002sbe.3 prossess.

Parameter annoDb is optional, if provided, extra columns including SYMBOL, GENENAME, ENSEMBL/ENTREZID will be added. The geneId column in annotation output will be consistent with the geneID in TxDb. If it is ENTREZID, ENSEMBL will be added if annoDb is provided, while if it is ENSEMBL ID, ENTREZID will be added.

The TxDb class is a container for storing transcript annotations. Bioconductor provides several packages containing TxDb objects for model organisms sur as Human and mouse. For instance, TxDb.Hsapiens.UCSC.hg38.knownGene, TxDb.Hsapiens.UCSC.hg19.knownGene for human genome hg38 and hg19, TxDb.Mmusculus.UCSC.mm10.knownGene and TxDb.Mmusculus.UCSC.mm9.knownGene for mouse genome mm10 and mm9, etc. User can also prepare their own TxDb by retrieving information from UCSC Genome Bioinformatics and BioMart data resources by R function makeTxDbFromBiomart and makeTxDbFromUCSC. One can also create a TxDb objects for his favourite organism using an annotation file in GTF/GFF format using the function makeTxDbFromGFF or the package GenomicFeatures.

```{r createTxDbGTF, include=TRUE, eval=FALSE}
## download GTF file
download.file("https://ftp.ncbi.nlm.nih.gov/genomes/all/annotation_releases/93934/101/GCF_001577835.2_Coturnix_japonica_2.1/GCF_001577835.2_Coturnix_japonica_2.1_genomic.gtf.gz", "Coturnix_japonica_2.1.annotation.gtf.gz")

## Build TxDb object
library(GenomicFeatures)
txdb = makeTxDbFromGFF("Coturnix_japonica_2.1.annotation.gtf.gz")

## To save the txdb database
library(AnnotationDbi)
saveDb(txdb, 'txdb.Coturnix_japonica_2.1.sqlite')

## load it when needed
library(AnnotationDbi)
txdb = loadDb(file = 'txdb.Coturnix_japonica_2.1.sqlite')
```

### Visualize genomic annotation
We can now analyze more in details genomic features associated to our peaks (introns, exons, promoters, distal regions,...).

```{r genomicFeatureDistribution, include=TRUE, eval=TRUE}
## distribution of genomic features for BRG1 peaks
# as a pie chart - which is the most widely used representation in publication
plotAnnoPie(peakAnno$BRG1)

# as a barplot
plotAnnoBar(peakAnno$BRG1)
```

However since some annotation overlap, ChIPseeker provides functions that help having a view of full annotation overlap.
```{r upsetR, include=TRUE, eval=TRUE}
library(UpSetR)
upsetplot(peakAnno$BRG1)
```

Representation with barplot is the most convenient view when looking at several datasets at once show the distribution of genomic features for all peak sets at once
```{r annotAllOnce, include=TRUE, eval=TRUE}
plotAnnoBar(peakAnno)
```

### Importance of the annotation database
In the previous section, we have annotated peaks using annotation from UCSC's knownGene. The database chosen for annotation can have an impact on subsequent results including data integration such as comparison between genes associated to peaks and gene expression using RNA-seq data for instance.

Let's look at the overlap between genes expressed in RNA-seq data with genes associated to peaks (let's remind that peaks are associated to closest genes if no other evidences are used).

```{r compareAnnot, include=TRUE, eval=TRUE}
## Download GTF files
library(GenomicFeatures)
## GTF file downloaded from https://ftp.ncbi.nlm.nih.gov/genomes/all/GCA/000/001/405/GCA_000001405.15_GRCh38/seqs_for_alignment_pipelines.ucsc_ids/GCA_000001405.15_GRCh38_full_analysis_set.refseq_annotation.gtf.gz
txdb.refseq = makeTxDbFromGFF("data/GCA_000001405.15_GRCh38_full_analysis_set.refseq_annotation.gtf.gz")
txdb.ensembl = makeTxDbFromGFF("data/Homo_sapiens.GRCh38.103_UCSC_chr.gtf.gz")

## Ensembl TxDB can also been download using the function makeTxDbFromBiomart
# txdb.ensembl <- makeTxDbFromBiomart(biomart="ENSEMBL_MART_ENSEMBL",
  # host="nov2020.archive.ensembl.org", dataset="hsapiens_gene_ensembl")

annot <- list()
annot[["ensembl"]] <- annotatePeak(peaks$BRG1, tssRegion=c(-1000, 100), TxDb=txdb.ensembl, annoDb="org.Hs.eg.db")
annot[["refseq"]] <- annotatePeak(peaks$BRG1, tssRegion=c(-1000, 100), TxDb=txdb.refseq, annoDb="org.Hs.eg.db")

rnaseq <- read.table(paste0(params$path.rnaseq, params$rnaseq), header=TRUE,
          check.names = FALSE, quote="", sep="\t")



```

## Link and external references
  * [ChIPseeker](https://bioconductor.org/packages/release/bioc/vignettes/ChIPseeker/inst/doc/ChIPseeker.html)
  * [GRanges](https://bioconductor.org/packages/release/bioc/vignettes/GenomicRanges/inst/doc/GenomicRangesIntroduction.html)
  * [EnrichedHeatmap](https://bioconductor.org/packages/release/bioc/vignettes/EnrichedHeatmap/inst/doc/EnrichedHeatmap.html)
  * [ChIPpeakAnno](https://www.bioconductor.org/packages/release/bioc/vignettes/ChIPpeakAnno/inst/doc/pipeline.html)


## Session info
```{r sessionInfo, include=TRUE, eval=TRUE}
sessionInfo()
```
