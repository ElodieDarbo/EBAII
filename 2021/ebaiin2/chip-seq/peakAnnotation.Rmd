---
title: "EBAIIn2 - ChIP-seq Workshop - Peak annotation"
date: "2021 May, 27th"
output:
  html_document:
    toc: true
    toc_depth: 3
  pdf_document:
    fig_caption: yes
    keep_tex: yes
    toc: true
    toc_depth: 3
params:
  path.peaks: /Volumes/ngs/illumina/slegras/B21000_EBAIIv2/2021-05-07_PeakCalling/
  brg1: BRG1siCTRL_CHIP-seq/BRG1siCTRL_CHIP-seq_peaks.narrowPeak
  mitf: MITF_CHIP-seq/MITF_CHIP-seq_peaks.narrowPeak
  sox10: SOX10_CHIP-seq/SOX10_CHIP-seq_peaks.narrowPeak
  ensembl: 103
  assembly: hg38
  organism: Homo sapiens
bibliography: references.bib
---

```{r setup, include=FALSE}
knitr::opts_knit$set(echo = TRUE,  root.dir="/Users/slegras/Documents/Formations/EBAII/2021/ebaiin2/chip-seq/", fig.path = "images/")
```

## Load data
During this training session we are going to use some features from the package ChIPseeker. Load it.
```{r setupenv, message=FALSE, include=TRUE}
library(ChIPseeker)
```

Peak files are in narrowPeak format which is of the form ([source](https://genome.ucsc.edu/FAQ/FAQformat.html#format12)):

1. chrom - Name of the chromosome (or contig, scaffold, etc.).
2. chromStart - The starting position of the feature in the chromosome or scaffold. The first base in a chromosome is numbered 0.
3. chromEnd - The ending position of the feature in the chromosome or scaffold. The chromEnd base is not included in the display of the feature. For example, the first 100 bases of a chromosome are defined as chromStart=0, chromEnd=100, and span the bases numbered 0-99.
4. name - Name given to a region (preferably unique). Use "." if no name is assigned.
5. score - Indicates how dark the peak will be displayed in the browser (0-1000). If all scores were "'0"' when the data were submitted to the DCC, the DCC assigned scores 1-1000 based on signal value. Ideally the average signalValue per base spread is between 100-1000.
6. strand - +/- to denote strand or orientation (whenever applicable). Use "." if no orientation is assigned.
7. signalValue - Measurement of overall (usually, average) enrichment for the region.
8. pValue - Measurement of statistical significance (-log10). Use -1 if no pValue is assigned.
9. qValue - Measurement of statistical significance using false discovery rate (-log10). Use -1 if no qValue is assigned.
10. peak - Point-source called for this peak; 0-based offset from chromStart. Use -1 if no point-source called.

```{r loadData, include=TRUE}
peaks <- list()
peaks[["BRG1"]] <- readPeakFile(paste0(params$path.peaks, params$brg1), as="GRanges")
peaks[["MITF"]] <- readPeakFile(paste0(params$path.peaks, params$mitf), as="GRanges")
peaks[["SOX10"]] <- readPeakFile(paste0(params$path.peaks, params$sox10), as="GRanges")
peaks
```

Peaks are stored as **GenomicRanges** objects; this is an R format which look like the bed format, but is optimized in terms of memory requirements and speed of execution.

We can start by computing some basic statistics on the peak sets.

## ChIP-seq data description
### How many peaks were called?
Check the number of peak sets
```{r peaksStats1, include=TRUE}
length(peaks)
```

Compute the number of peaks for all datasets using the list object
```{r peaksStats2, include=TRUE}
sapply(peaks,length)
```

Make a simple barplot showing the number of peaks per chipped protein
```{r simplebarplot, include=TRUE}
barplot(sapply(peaks,length))
```

Let's create a barplot with ggplot2 out of this data.
```{r enhancedbarplot, include=TRUE}
# Load ggplot2 library
library(ggplot2)

# create a table with the data to display
# sapply apply the same function (here length) to all elements
# of the list "peaks"
# sapply() function takes list, vector or data frame as input and gives output in vector or matrix
peak.lengths <- data.frame(IP=names(peaks),
                           NbPeaks=sapply(peaks,length))

# make the barplot
ggplot(peak.lengths, aes(x=IP, y=NbPeaks)) +
         geom_bar(stat="identity")

# Let's add colors to the barplot
# In R it exists some already defined colors palettes
# the most widely used palette is RColorBrewer.
# This R library offers several color palettes
# See:
library(RColorBrewer)
par(mar=c(3,4,2,2))
display.brewer.all()

# now lets add colors to the barplot
# first ass the new information, fill=IP to let ggplot know
# that colors change based on chipped protein
ggplot(peak.lengths, aes(x=IP, y=NbPeaks, fill=IP)) +
         geom_bar(stat="identity")

# if we want to use colors from RColorBrewer library
# with the "Set1" color palette
ggplot(peak.lengths, aes(x=IP, y=NbPeaks, fill=IP)) +
         geom_bar(stat="identity")+
         scale_fill_brewer(palette="Set1")
```

### How large are these peaks?
Compute statistics on BRG1 peak sizes
```{r peakWidth, message=FALSE, include=TRUE}
## we use the function width() from GenomicRanges
library(GenomicRanges)
summary(width(peaks$BRG1))
```

Now, get the same for all peaks.
```{r peakWidth, message=FALSE, include=TRUE}
## lapply() function is useful for performing operations on list objects and returns a list object of same length of original set.
peak.width = lapply(peaks,width)
lapply(peak.width,summary)
```

Create a simple boxplot of the peak sizes
```{r simpleboxplot, message=FALSE, include=TRUE}
boxplot(peak.width)
```

Now, create a nice looking boxplot with ggplot2. ggplot takes a data frame as input. We can either create a date frame, this is what we have done when we created the barplot. Here, we are going to use a package that creates a data frame from other types of data: reshape2.
```{r reshape, message=FALSE, include=TRUE}
# Load the package
library(reshape2)
peak.width.table <- melt(peak.width)
head(peak.width.table)
```

In this table, there is as many rows as the total number of peaks in all peak sets. It contains all possible pairs IP <-> number of peaks possible
```{r reshapeCheck, message=FALSE, include=TRUE}
# Number of peaks per chipped protein
sapply(peaks, length)
# total number of peaks
sum(sapply(peaks, length))
# size of the table we've just generated
dim(peak.width.table)
```

Now create a nice looking boxplot
```{r enhancedboxplot1, message=FALSE, include=TRUE}
ggplot(peak.width.table, aes(x=L1, y=value)) +
         geom_boxplot()
```


Enhance it.
```{r enhancedboxplot2, message=FALSE, include=TRUE}
# - theme_classic() change grey background to white background
# - fill=L1 and scale_fill_brewer(palette="Set1") colors boxplots
# based on chipped protein and with colors from RColorBrewer Set1 palette
# - labs changes x and y axis labels and legend title
# - scale_y_log10() set y axis to a log scale so that we can have a nice
# view of the data in small values
ggplot(peak.width.table, aes(x=L1, y=value, fill=L1)) +
         geom_boxplot()+
         theme_classic()+
         scale_fill_brewer(palette="Set1")+
         labs(x = "", y = "Peak sizes", fill = "")+
         scale_y_log10()

```

<!-- #### What is the score of these peaks?

Can you adapt the previous code to display a boxplot of the peak score distribution for the Forebrain peak set (column `Maximum.Peak.Height`)? -->

## Where are the peaks located over the whole genome?

We can now display the genomic distribution of the peaks along the chromosomes, including the peak scores, using the `covplot` function from `ChIPSeeker`:

```{r peakGenomeDistribution, include=TRUE}
# genome wide BRG1 peak distribution
covplot(peaks$BRG1, weightCol="V5")

# chromosome wide BRG1 peak distribution
covplot(peaks$BRG1, chrs=c("chr1", "chr2"), weightCol="V5")
```

## Functional annotation of the peaks
We can now assign peaks to the closest genes and genomic features (introns, exons, promoters, distal regions, etc...).
This is done using the function `annotatePeak` which compares peak positions with the genomic feature positions of the reference genome. This function returns
a complex object which contains all this information.

```{r annotatePeaks, eval=TRUE, message=FALSE, include=TRUE}
## org.Hs.eg.db is an R object that contains mappings between Entrez Gene identifiers and GenBank accession numbers.
library(org.Hs.eg.db)

## Annotate peaks for all datasets and store it in a list
peakAnno <- list()
peakAnno[["BRG1"]] = annotatePeak(peaks$BRG1, tssRegion=c(-1000, 100), TxDb=txdb, annoDb="org.Hs.eg.db")
peakAnno[["MITF"]] = annotatePeak(peaks$MITF, tssRegion=c(-1000, 100), TxDb=txdb, annoDb="org.Hs.eg.db")
peakAnno[["SOX10"]] = annotatePeak(peaks$SOX10, tssRegion=c(-1000, 100), TxDb=txdb, annoDb="org.Hs.eg.db")
```

### Genomic localization
We can now analyze more in details genomic features associated to our peaks (introns, exons, promoters, distal regions,...)

```{r genomicFeatureDistribution, include=TRUE, eval=TRUE}
## distribution of genomic features for BRG1 peaks
# as a pie chart - which is the most widely used representation in publication
plotAnnoPie(peakAnno$BRG1)

# as a barplot
plotAnnoBar(peakAnno$BRG1)
```

However since some annotation overlap, ChIPseeker provides functions that help having a view of full annotation overlap
```{r upsetR, include=TRUE, eval=TRUE}
library(UpSetR)
upsetplot(peakAnno$BRG1)

## Representation with barplot is the most convenient view when looking
## at several datasets at once
## show the distribution of genomic features for all peak sets at once
plotAnnoBar(peakAnno)
```

## session info
```{r sessionInfo, include=TRUE, eval=TRUE}
sessionInfo()
```
